## 'makeCacheMatrix' creates a special "matrix", with a list of functions to
# 1. Set the value of a matrix x (set)
# 2. Retrieve the value of the matrix (get)
# 3. Set the value of the matrix' inverse (setinv)
# 4. Retrieve the value of the matrix' inverse (getinv)

#The default argument value is an empty matrix, otherwise x will not be
#initialized if no argument is passed  => 'get' will not work until x is
#explicitly initialized with 'set'

makeCacheMatrix <- function(x = matrix()) {
    
    #initialize the inverse matrix as NULL
    
    inv<- NULL
    
    #'set' function allows to "re-initialize" the matrix
    # it assumes, a matrix is passed to it
    
    set <- function(y) {
        
        #Store the new matrix value (y) in the environment of 'makeCacheMatrix'
        x <<- y
        
        #reset the inverse to NULL whenever the matrix is reset
        
        inv <<- NULL 
    }
    
    get <- function() x #retrieves x
    
    #Function to store a new inverse value ('inverse') in the
    #environment of 'makeCacheMatrix'
    setinv <- function(inverse) inv <<- inverse
    
    getinv <- function() inv #retrieves inv
    
    #assign functions to a list of function names, so that they can be
    #called using x$<function_name>
    list(set = set, get = get,
         setinv = setinv,
         getinv = getinv)

}



# 'cacheSolve' checks if the inverse of matrix x is stored, provided x was 
# generated by makeCacheMatrix. If an inverse is stored, the function returns it. 
# If not, it calculates the inverse and stores it.
#As per assignment, the function assumes, the matrix is always invertible, 
#so no special checks are added for that

cacheSolve <- function(x, ...) {
    #get the inverse value stored in x
    
    inv <- x$getinv()
    
    #Check if a non-NULL value is already stored. If yes, return cached data
    
    if(!is.null(inv)) {
        message("getting cached data")
        return(inv)
    }
    
    #If inv=NULL, get the matrix & calculate its inverse
    #1. Retrieve the matrix
    
    data <- x$get()
    
    #2. Calculate the inverse using the standard R function. 
    #It is the solution to data*inv=I, where I is identity matrix of same size
    #Since only square matrices can be inverted, we can use number of columns
    #or number of rows in data to determine the size for I
    
    inv <- solve(data,diag(ncol(data)), ...)
    
    #3. Store the new value of the inverse & print it in the console
    
    x$setinv(inv)
    inv
}

